"""
有 N 件物品和一个容量是 V 的背包。。

第 i 件物品的体积是 vi，价值是 wi。

每件物品只能使用一次
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。
"""

# 思路来源
# 答案来源 https://www.acwing.com/solution/acwing/content/4129/

def bagO1():
    N, V = map(int, input().split())


    # 为什么这里v,w第一个元素要放0，是因为下面for循环，我们遍历i是从1开始的
    # 因为不存在所谓的0号元素，所以我们统一把元素价值往后挪
    v = [0] # 体积
    w = [0] # 价值

    for i in range(N):
        comb = [int(i) for i in input().split()]
        v.append(comb[0])
        w.append(comb[1])


    # 初始化，先全部赋值为0，这样至少体积为0或者不选任何物品的时候是满足要求
    # 从前i个物体中选，且已选择物体的总体积<= j，的最大价值。
    dp = [[0] * (V + 1) for j in range(N + 1)]

    # 从前i个物体中选
    for i in range(1, N + 1):
        # j代表容量
        for j in range(1, V + 1):
            # 不选，第i个物品的状态
            # 当前状态等于上一个状态了
            dp[i][j] = dp[i - 1][j]

            # 判断背包容量是不是大于第i件物品的体积, 只有大于的情况下才有可能选择当前物品
            if j >= v[i]:
                # 选，第i个物品的状态
                # 在选和不选两种方案中选出最大值
                dp[i][j] = max(dp[i-1][j], dp[i - 1][j - v[i]] + w[i])

    return dp[-1][-1]


"""
https://www.acwing.com/video/944/
"""

def bagO1compress():
    N, V = map(int, input().split())

    v = [0]
    w = [0]

    for i in range(N):
        comb = [int(i) for i in input().split()]
        v.append(comb[0])
        w.append(comb[1])


    # 初始化，先全部赋值为0，这样至少体积为0或者不选任何物品的时候是满足要求
    dp = [0 for j in range(V + 1)]


    for i in range(1, N + 1):
        for j in range(V, v[i] - 1, -1):
            # 不选，第i个物品的状态
            # 当前状态等于上一个状态了
            dp[j] = dp[j]
            # dp[i][j] = dp[i - 1][j]

            # 选，第i个物品的状态
            if j >= v[i]:
                # 在选和不选两种方案中选出最大值
                dp[j] = max(dp[j], dp[j - v[i]] + w[i])
                """
                dp[i][j] = max(dp[i-1][j], dp[i - 1][j - v[i]] + w[i])
                为什么可以把 dp[i - 1][j - v[i]] => dp[j - v[i]]
                因为dp[i - 1]，代表是上一次循环的状态
                所以我们只要在计算dp[j]的时候，让dp[j - v[i]]还是处于上一次循环的状态就好了
                
                如何让dp[j - v[i]]处于上一次循环的状态呢
                我们需要从后往前遍历
                因为dp[j] 会先于 dp[j - v[i]]更新状态，所以我们就相当于使用了上一个循环的状态
                """


    return dp[-1]



"""
如何进行空间压缩
我们可以把 dp[i][j] 变为 dp[j] 表示放入容量为j的背包可以获得的最大价值

dp[j] = max(dp[j], dp[j - v[i]] + w[i]) 
dp[j]表示不取第i件物品，前i-1个物品的价值是多少那价值就是多少
dp[[j-v[i]] + w[i] 表示取第i件物品， 那么它的价值就为前i-1个物品的价值 + i的价值
                                    前j个物品的价值为 dp[j - v[i]]

为什么遍历j的时候要从后往前？
因为我们使用dp自身作为一种动态压缩
所以当 dp[j] = max(dp[j], dp[j - v[i]] + w[i])时， dp[j]是作为现在的状态，但是dp[j - v[i]] + w[i]是作为上一次的状态

假如j 从前往后遍历的话，那么dp[j] = dp[j - v[i]] + w[i]， dp[j]是作为上一次的状态，dp[j - v[i]] + w[i]是作为本轮的状态
无法完成

重  价
1   2
2   4
3   4
4   5

一个例子：
[0, 2, 2, 2, 2, 2]    第一个物品选了重量1 价值2的
[0, 2, [4], 6, 6, 6]  第二轮选了重量2 价值4的, 放弃了重量1 价值2的
[0, 2, 4, [6], 6, 8]  第三轮选了 重量2 价值4，重量1 价值2
[0, 2, 4, 6, 6, [8]]  第四轮选了 重量2 价值4，重量1 价值2
                      第五轮选了 重量2 价值4，重量3 价值4 的，总和为8
"""

