"""
一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。

给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。

如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。

[0,1,3,5,6,8,12,17]

总共有8个石子。
第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,
第三个石子在序号为3的单元格的位置， 以此定义整个数组...
最后一个石子处于序号为17的单元格的位置。

返回 true。即青蛙可以成功过河，按照如下方案跳跃：
跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着
跳2个单位到第4块石子, 然后跳3个单位到第6块石子,
跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。
"""
class Solution(object):
    def canCross(self, stones):
        """
        :type stones: List[int]
        :rtype: bool
        """
        n = len(stones)
        self.stones = stones

        # 从第i个石头开始跳
        # 跳j个距离是否合法
        # 合法是1, 不合法是0, 当前状态没被记录是-1
        self.dp = [[-1] * (n + 1) for i in range(n + 1)]

        self.hashmap = {}
        for i in range(n):
            self.hashmap[stones[i]] = i

        # 第一次我们只能从0块石头开始，跳1步，然后设这个状态是base case
        # 假如说我们dp回到了这里，说明是可以跳回来的
        self.dp[0][1] = 1

        for i in range(1, n):
            # 我们这里是进行一个逐步分解，从最远的石头往回跳，看能不能跳回来
            # 因为每一步我们都可以j+1,所以我们最多可以跳n-1步，
            # 当然最少也只能跳1步,因为可以假设我们一直只跳一步
            if self.helper(n - 1, i):
                return True

        return False

    def helper(self, i, j):
        # 假如说从i块石头开始跳，跳到j，当前状态是被记录过的话(不为-1)
        # 那么直接返回那个状态
        if self.dp[i][j] != -1:
            return self.dp[i][j]

        # 初始化当前状态
        self.dp[i][j] = 0

        # 判断我们最少可以跳多少个石头，我们最少能跳一个石头
        start = max(1, j - 1)

        # k表示我们上一次跳到当前跳多少步
        # 它的选择范围是,假如说我们当前跳的步数是j, 我们上一次一可以跳j-1 j j+1
        # (j-1) + 1 = j(当前可以跳的步数)
        # (j+1) - 1 = j(当前可以跳的步数)
        # (j)       = j(当前可以跳的步数)
        for k in range(start, j + 2):
            # 看往回跳k步有没有石头
            if self.stones[i] - k in self.hashmap.keys():
                # 假如往回跳k步有石头的话，则记录那块石头的下标为p
                p = self.hashmap[self.stones[i] - k]
                # 然后从p跳k步到i,那我们再验证一下, p可不可以往前跳
                if self.helper(p, k):
                    self.dp[i][j] = 1
                    break
        return self.dp[i][j]

# https://www.acwing.com/video/1799/